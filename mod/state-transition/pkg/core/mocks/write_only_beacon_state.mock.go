// Code generated by mockery v2.46.3. DO NOT EDIT.

package mocks

import (
	common "github.com/berachain/beacon-kit/mod/primitives/pkg/common"

	math "github.com/berachain/beacon-kit/mod/primitives/pkg/math"

	mock "github.com/stretchr/testify/mock"
)

// WriteOnlyBeaconState is an autogenerated mock type for the WriteOnlyBeaconState type
type WriteOnlyBeaconState[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	mock.Mock
}

type WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	mock *mock.Mock
}

func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) EXPECT() *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{mock: &_m.Mock}
}

// AddValidator provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) AddValidator(_a0 ValidatorT) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AddValidator")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ValidatorT) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_AddValidator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddValidator'
type WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// AddValidator is a helper method to define mock.On call
//   - _a0 ValidatorT
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) AddValidator(_a0 interface{}) *WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("AddValidator", _a0)}
}

func (_c *WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 ValidatorT)) *WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ValidatorT))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(ValidatorT) error) *WriteOnlyBeaconState_AddValidator_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// AddValidatorBartio provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) AddValidatorBartio(_a0 ValidatorT) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AddValidatorBartio")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ValidatorT) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_AddValidatorBartio_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddValidatorBartio'
type WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// AddValidatorBartio is a helper method to define mock.On call
//   - _a0 ValidatorT
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) AddValidatorBartio(_a0 interface{}) *WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("AddValidatorBartio", _a0)}
}

func (_c *WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 ValidatorT)) *WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ValidatorT))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(ValidatorT) error) *WriteOnlyBeaconState_AddValidatorBartio_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// DecreaseBalance provides a mock function with given fields: _a0, _a1
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) DecreaseBalance(_a0 math.ValidatorIndex, _a1 math.Gwei) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DecreaseBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.ValidatorIndex, math.Gwei) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_DecreaseBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecreaseBalance'
type WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// DecreaseBalance is a helper method to define mock.On call
//   - _a0 math.ValidatorIndex
//   - _a1 math.Gwei
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) DecreaseBalance(_a0 interface{}, _a1 interface{}) *WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("DecreaseBalance", _a0, _a1)}
}

func (_c *WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 math.ValidatorIndex, _a1 math.Gwei)) *WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.ValidatorIndex), args[1].(math.Gwei))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.ValidatorIndex, math.Gwei) error) *WriteOnlyBeaconState_DecreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// IncreaseBalance provides a mock function with given fields: _a0, _a1
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) IncreaseBalance(_a0 math.ValidatorIndex, _a1 math.Gwei) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for IncreaseBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.ValidatorIndex, math.Gwei) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_IncreaseBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncreaseBalance'
type WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// IncreaseBalance is a helper method to define mock.On call
//   - _a0 math.ValidatorIndex
//   - _a1 math.Gwei
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) IncreaseBalance(_a0 interface{}, _a1 interface{}) *WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("IncreaseBalance", _a0, _a1)}
}

func (_c *WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 math.ValidatorIndex, _a1 math.Gwei)) *WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.ValidatorIndex), args[1].(math.Gwei))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.ValidatorIndex, math.Gwei) error) *WriteOnlyBeaconState_IncreaseBalance_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetEth1Data provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetEth1Data(_a0 Eth1DataT) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetEth1Data")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(Eth1DataT) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetEth1Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEth1Data'
type WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetEth1Data is a helper method to define mock.On call
//   - _a0 Eth1DataT
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetEth1Data(_a0 interface{}) *WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetEth1Data", _a0)}
}

func (_c *WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 Eth1DataT)) *WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(Eth1DataT))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(Eth1DataT) error) *WriteOnlyBeaconState_SetEth1Data_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetEth1DepositIndex provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetEth1DepositIndex(_a0 uint64) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetEth1DepositIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetEth1DepositIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEth1DepositIndex'
type WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetEth1DepositIndex is a helper method to define mock.On call
//   - _a0 uint64
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetEth1DepositIndex(_a0 interface{}) *WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetEth1DepositIndex", _a0)}
}

func (_c *WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 uint64)) *WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) error) *WriteOnlyBeaconState_SetEth1DepositIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetFork provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetFork(_a0 ForkT) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetFork")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ForkT) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetFork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetFork'
type WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetFork is a helper method to define mock.On call
//   - _a0 ForkT
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetFork(_a0 interface{}) *WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetFork", _a0)}
}

func (_c *WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 ForkT)) *WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ForkT))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(ForkT) error) *WriteOnlyBeaconState_SetFork_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetGenesisValidatorsRoot provides a mock function with given fields: root
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetGenesisValidatorsRoot(root common.Root) error {
	ret := _m.Called(root)

	if len(ret) == 0 {
		panic("no return value specified for SetGenesisValidatorsRoot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Root) error); ok {
		r0 = rf(root)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGenesisValidatorsRoot'
type WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetGenesisValidatorsRoot is a helper method to define mock.On call
//   - root common.Root
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetGenesisValidatorsRoot(root interface{}) *WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetGenesisValidatorsRoot", root)}
}

func (_c *WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(root common.Root)) *WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Root))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(common.Root) error) *WriteOnlyBeaconState_SetGenesisValidatorsRoot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetLatestBlockHeader provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetLatestBlockHeader(_a0 BeaconBlockHeaderT) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetLatestBlockHeader")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(BeaconBlockHeaderT) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetLatestBlockHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLatestBlockHeader'
type WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetLatestBlockHeader is a helper method to define mock.On call
//   - _a0 BeaconBlockHeaderT
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetLatestBlockHeader(_a0 interface{}) *WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetLatestBlockHeader", _a0)}
}

func (_c *WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 BeaconBlockHeaderT)) *WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(BeaconBlockHeaderT))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(BeaconBlockHeaderT) error) *WriteOnlyBeaconState_SetLatestBlockHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetLatestExecutionPayloadHeader provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetLatestExecutionPayloadHeader(_a0 ExecutionPayloadHeaderT) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetLatestExecutionPayloadHeader")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ExecutionPayloadHeaderT) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLatestExecutionPayloadHeader'
type WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetLatestExecutionPayloadHeader is a helper method to define mock.On call
//   - _a0 ExecutionPayloadHeaderT
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetLatestExecutionPayloadHeader(_a0 interface{}) *WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetLatestExecutionPayloadHeader", _a0)}
}

func (_c *WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 ExecutionPayloadHeaderT)) *WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ExecutionPayloadHeaderT))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(ExecutionPayloadHeaderT) error) *WriteOnlyBeaconState_SetLatestExecutionPayloadHeader_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetNextWithdrawalIndex provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetNextWithdrawalIndex(_a0 uint64) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetNextWithdrawalIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetNextWithdrawalIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNextWithdrawalIndex'
type WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetNextWithdrawalIndex is a helper method to define mock.On call
//   - _a0 uint64
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetNextWithdrawalIndex(_a0 interface{}) *WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetNextWithdrawalIndex", _a0)}
}

func (_c *WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 uint64)) *WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) error) *WriteOnlyBeaconState_SetNextWithdrawalIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetNextWithdrawalValidatorIndex provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetNextWithdrawalValidatorIndex(_a0 math.ValidatorIndex) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetNextWithdrawalValidatorIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.ValidatorIndex) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNextWithdrawalValidatorIndex'
type WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetNextWithdrawalValidatorIndex is a helper method to define mock.On call
//   - _a0 math.ValidatorIndex
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetNextWithdrawalValidatorIndex(_a0 interface{}) *WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetNextWithdrawalValidatorIndex", _a0)}
}

func (_c *WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 math.ValidatorIndex)) *WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.ValidatorIndex))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.ValidatorIndex) error) *WriteOnlyBeaconState_SetNextWithdrawalValidatorIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetSlot provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetSlot(_a0 math.Slot) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetSlot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.Slot) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSlot'
type WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetSlot is a helper method to define mock.On call
//   - _a0 math.Slot
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetSlot(_a0 interface{}) *WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetSlot", _a0)}
}

func (_c *WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 math.Slot)) *WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.Slot))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.Slot) error) *WriteOnlyBeaconState_SetSlot_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetTotalSlashing provides a mock function with given fields: _a0
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetTotalSlashing(_a0 math.Gwei) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for SetTotalSlashing")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.Gwei) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_SetTotalSlashing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTotalSlashing'
type WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// SetTotalSlashing is a helper method to define mock.On call
//   - _a0 math.Gwei
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetTotalSlashing(_a0 interface{}) *WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetTotalSlashing", _a0)}
}

func (_c *WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 math.Gwei)) *WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.Gwei))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.Gwei) error) *WriteOnlyBeaconState_SetTotalSlashing_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateBlockRootAtIndex provides a mock function with given fields: _a0, _a1
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateBlockRootAtIndex(_a0 uint64, _a1 common.Root) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBlockRootAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, common.Root) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBlockRootAtIndex'
type WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// UpdateBlockRootAtIndex is a helper method to define mock.On call
//   - _a0 uint64
//   - _a1 common.Root
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateBlockRootAtIndex(_a0 interface{}, _a1 interface{}) *WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateBlockRootAtIndex", _a0, _a1)}
}

func (_c *WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 uint64, _a1 common.Root)) *WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(common.Root))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64, common.Root) error) *WriteOnlyBeaconState_UpdateBlockRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateRandaoMixAtIndex provides a mock function with given fields: _a0, _a1
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateRandaoMixAtIndex(_a0 uint64, _a1 common.Bytes32) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRandaoMixAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, common.Bytes32) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRandaoMixAtIndex'
type WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// UpdateRandaoMixAtIndex is a helper method to define mock.On call
//   - _a0 uint64
//   - _a1 common.Bytes32
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateRandaoMixAtIndex(_a0 interface{}, _a1 interface{}) *WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateRandaoMixAtIndex", _a0, _a1)}
}

func (_c *WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 uint64, _a1 common.Bytes32)) *WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(common.Bytes32))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64, common.Bytes32) error) *WriteOnlyBeaconState_UpdateRandaoMixAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateSlashingAtIndex provides a mock function with given fields: _a0, _a1
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateSlashingAtIndex(_a0 uint64, _a1 math.Gwei) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSlashingAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, math.Gwei) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_UpdateSlashingAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSlashingAtIndex'
type WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// UpdateSlashingAtIndex is a helper method to define mock.On call
//   - _a0 uint64
//   - _a1 math.Gwei
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateSlashingAtIndex(_a0 interface{}, _a1 interface{}) *WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateSlashingAtIndex", _a0, _a1)}
}

func (_c *WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 uint64, _a1 math.Gwei)) *WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(math.Gwei))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64, math.Gwei) error) *WriteOnlyBeaconState_UpdateSlashingAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateStateRootAtIndex provides a mock function with given fields: _a0, _a1
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateStateRootAtIndex(_a0 uint64, _a1 common.Root) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStateRootAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, common.Root) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_UpdateStateRootAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStateRootAtIndex'
type WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// UpdateStateRootAtIndex is a helper method to define mock.On call
//   - _a0 uint64
//   - _a1 common.Root
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateStateRootAtIndex(_a0 interface{}, _a1 interface{}) *WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateStateRootAtIndex", _a0, _a1)}
}

func (_c *WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 uint64, _a1 common.Root)) *WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(common.Root))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64, common.Root) error) *WriteOnlyBeaconState_UpdateStateRootAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateValidatorAtIndex provides a mock function with given fields: _a0, _a1
func (_m *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateValidatorAtIndex(_a0 math.ValidatorIndex, _a1 ValidatorT) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateValidatorAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.ValidatorIndex, ValidatorT) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteOnlyBeaconState_UpdateValidatorAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateValidatorAtIndex'
type WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any] struct {
	*mock.Call
}

// UpdateValidatorAtIndex is a helper method to define mock.On call
//   - _a0 math.ValidatorIndex
//   - _a1 ValidatorT
func (_e *WriteOnlyBeaconState_Expecter[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateValidatorAtIndex(_a0 interface{}, _a1 interface{}) *WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateValidatorAtIndex", _a0, _a1)}
}

func (_c *WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 math.ValidatorIndex, _a1 ValidatorT)) *WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.ValidatorIndex), args[1].(ValidatorT))
	})
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.ValidatorIndex, ValidatorT) error) *WriteOnlyBeaconState_UpdateValidatorAtIndex_Call[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// NewWriteOnlyBeaconState creates a new instance of WriteOnlyBeaconState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWriteOnlyBeaconState[BeaconBlockHeaderT any, Eth1DataT any, ExecutionPayloadHeaderT any, ForkT any, ValidatorT any](t interface {
	mock.TestingT
	Cleanup(func())
}) *WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	mock := &WriteOnlyBeaconState[BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
