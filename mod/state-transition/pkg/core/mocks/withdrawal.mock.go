// Code generated by mockery v2.46.3. DO NOT EDIT.

package mocks

import (
	common "github.com/berachain/beacon-kit/mod/primitives/pkg/common"

	math "github.com/berachain/beacon-kit/mod/primitives/pkg/math"

	mock "github.com/stretchr/testify/mock"
)

// Withdrawal is an autogenerated mock type for the Withdrawal type
type Withdrawal[WithdrawalT any] struct {
	mock.Mock
}

type Withdrawal_Expecter[WithdrawalT any] struct {
	mock *mock.Mock
}

func (_m *Withdrawal[WithdrawalT]) EXPECT() *Withdrawal_Expecter[WithdrawalT] {
	return &Withdrawal_Expecter[WithdrawalT]{mock: &_m.Mock}
}

// Equals provides a mock function with given fields: _a0
func (_m *Withdrawal[WithdrawalT]) Equals(_a0 WithdrawalT) bool {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Equals")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(WithdrawalT) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Withdrawal_Equals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Equals'
type Withdrawal_Equals_Call[WithdrawalT any] struct {
	*mock.Call
}

// Equals is a helper method to define mock.On call
//   - _a0 WithdrawalT
func (_e *Withdrawal_Expecter[WithdrawalT]) Equals(_a0 interface{}) *Withdrawal_Equals_Call[WithdrawalT] {
	return &Withdrawal_Equals_Call[WithdrawalT]{Call: _e.mock.On("Equals", _a0)}
}

func (_c *Withdrawal_Equals_Call[WithdrawalT]) Run(run func(_a0 WithdrawalT)) *Withdrawal_Equals_Call[WithdrawalT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(WithdrawalT))
	})
	return _c
}

func (_c *Withdrawal_Equals_Call[WithdrawalT]) Return(_a0 bool) *Withdrawal_Equals_Call[WithdrawalT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Withdrawal_Equals_Call[WithdrawalT]) RunAndReturn(run func(WithdrawalT) bool) *Withdrawal_Equals_Call[WithdrawalT] {
	_c.Call.Return(run)
	return _c
}

// GetAddress provides a mock function with given fields:
func (_m *Withdrawal[WithdrawalT]) GetAddress() common.ExecutionAddress {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAddress")
	}

	var r0 common.ExecutionAddress
	if rf, ok := ret.Get(0).(func() common.ExecutionAddress); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.ExecutionAddress)
		}
	}

	return r0
}

// Withdrawal_GetAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddress'
type Withdrawal_GetAddress_Call[WithdrawalT any] struct {
	*mock.Call
}

// GetAddress is a helper method to define mock.On call
func (_e *Withdrawal_Expecter[WithdrawalT]) GetAddress() *Withdrawal_GetAddress_Call[WithdrawalT] {
	return &Withdrawal_GetAddress_Call[WithdrawalT]{Call: _e.mock.On("GetAddress")}
}

func (_c *Withdrawal_GetAddress_Call[WithdrawalT]) Run(run func()) *Withdrawal_GetAddress_Call[WithdrawalT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Withdrawal_GetAddress_Call[WithdrawalT]) Return(_a0 common.ExecutionAddress) *Withdrawal_GetAddress_Call[WithdrawalT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Withdrawal_GetAddress_Call[WithdrawalT]) RunAndReturn(run func() common.ExecutionAddress) *Withdrawal_GetAddress_Call[WithdrawalT] {
	_c.Call.Return(run)
	return _c
}

// GetAmount provides a mock function with given fields:
func (_m *Withdrawal[WithdrawalT]) GetAmount() math.Gwei {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAmount")
	}

	var r0 math.Gwei
	if rf, ok := ret.Get(0).(func() math.Gwei); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.Gwei)
	}

	return r0
}

// Withdrawal_GetAmount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAmount'
type Withdrawal_GetAmount_Call[WithdrawalT any] struct {
	*mock.Call
}

// GetAmount is a helper method to define mock.On call
func (_e *Withdrawal_Expecter[WithdrawalT]) GetAmount() *Withdrawal_GetAmount_Call[WithdrawalT] {
	return &Withdrawal_GetAmount_Call[WithdrawalT]{Call: _e.mock.On("GetAmount")}
}

func (_c *Withdrawal_GetAmount_Call[WithdrawalT]) Run(run func()) *Withdrawal_GetAmount_Call[WithdrawalT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Withdrawal_GetAmount_Call[WithdrawalT]) Return(_a0 math.Gwei) *Withdrawal_GetAmount_Call[WithdrawalT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Withdrawal_GetAmount_Call[WithdrawalT]) RunAndReturn(run func() math.Gwei) *Withdrawal_GetAmount_Call[WithdrawalT] {
	_c.Call.Return(run)
	return _c
}

// GetIndex provides a mock function with given fields:
func (_m *Withdrawal[WithdrawalT]) GetIndex() math.U64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetIndex")
	}

	var r0 math.U64
	if rf, ok := ret.Get(0).(func() math.U64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	return r0
}

// Withdrawal_GetIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIndex'
type Withdrawal_GetIndex_Call[WithdrawalT any] struct {
	*mock.Call
}

// GetIndex is a helper method to define mock.On call
func (_e *Withdrawal_Expecter[WithdrawalT]) GetIndex() *Withdrawal_GetIndex_Call[WithdrawalT] {
	return &Withdrawal_GetIndex_Call[WithdrawalT]{Call: _e.mock.On("GetIndex")}
}

func (_c *Withdrawal_GetIndex_Call[WithdrawalT]) Run(run func()) *Withdrawal_GetIndex_Call[WithdrawalT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Withdrawal_GetIndex_Call[WithdrawalT]) Return(_a0 math.U64) *Withdrawal_GetIndex_Call[WithdrawalT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Withdrawal_GetIndex_Call[WithdrawalT]) RunAndReturn(run func() math.U64) *Withdrawal_GetIndex_Call[WithdrawalT] {
	_c.Call.Return(run)
	return _c
}

// GetValidatorIndex provides a mock function with given fields:
func (_m *Withdrawal[WithdrawalT]) GetValidatorIndex() math.ValidatorIndex {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetValidatorIndex")
	}

	var r0 math.ValidatorIndex
	if rf, ok := ret.Get(0).(func() math.ValidatorIndex); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.ValidatorIndex)
	}

	return r0
}

// Withdrawal_GetValidatorIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValidatorIndex'
type Withdrawal_GetValidatorIndex_Call[WithdrawalT any] struct {
	*mock.Call
}

// GetValidatorIndex is a helper method to define mock.On call
func (_e *Withdrawal_Expecter[WithdrawalT]) GetValidatorIndex() *Withdrawal_GetValidatorIndex_Call[WithdrawalT] {
	return &Withdrawal_GetValidatorIndex_Call[WithdrawalT]{Call: _e.mock.On("GetValidatorIndex")}
}

func (_c *Withdrawal_GetValidatorIndex_Call[WithdrawalT]) Run(run func()) *Withdrawal_GetValidatorIndex_Call[WithdrawalT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Withdrawal_GetValidatorIndex_Call[WithdrawalT]) Return(_a0 math.ValidatorIndex) *Withdrawal_GetValidatorIndex_Call[WithdrawalT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Withdrawal_GetValidatorIndex_Call[WithdrawalT]) RunAndReturn(run func() math.ValidatorIndex) *Withdrawal_GetValidatorIndex_Call[WithdrawalT] {
	_c.Call.Return(run)
	return _c
}

// NewWithdrawal creates a new instance of Withdrawal. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWithdrawal[WithdrawalT any](t interface {
	mock.TestingT
	Cleanup(func())
}) *Withdrawal[WithdrawalT] {
	mock := &Withdrawal[WithdrawalT]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
